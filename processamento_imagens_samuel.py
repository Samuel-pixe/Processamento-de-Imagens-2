# -*- coding: utf-8 -*-
"""Processamento_Imagens_Samuel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/github/Samuel-pixe/Processamento-de-Imagens/blob/main/Processamento_Imagens_Python_Samuel.ipynb

### **Imagens**
"""

#!wget "https://www.ime.usp.br/~yoshi/2015ii/ccm118/sandbox/2015.10.14/Data/peppers.jpg"
#!wget "https://links.uwaterloo.ca/Repository/TIF/sail.tif"
#!wget "https://links.uwaterloo.ca/Repository/TIF/lena3.tif"
#!wget "https://links.uwaterloo.ca/Repository/TIF/tulips.tif"
#!wget "https://clipart.info/images/ccovers/1559839303multiple-star-png-20.png" -O "estrelas.png"
#!wget "https://www.kindpng.com/picc/m/427-4275311_clip-art-frutas-ma-png-imagens-apple-fruit.png" -O "apple.png"

#!wget "https://lh5.googleusercontent.com/tTv3nC4th8OavIzTSREGgwxRgEJD3ELM7Qzv3iXsbatf4oLaB0_vaX8KcSxQsWFrPzKBb_HYacMczbQ=w1007-h657" -O "estatua.jpg"

#!wget "https://lh3.googleusercontent.com/pw/AM-JKLWSt3MppGOyU4aFUgDjkhePIWo0ICjfX_H4V2MBeI2Eyp192Yi6CWGUvZ083EKpk7VL4dLy6vITMD4KNeOd9TOuHWuGVKnUK7pUvn_v23xTzYuYAxOnQZYPOICwFUdqqrIOFNyPlFeI439kBK1uZ8Qd=w589-h301-no?authuser=0&quot" -O "rodovia.jpg"

#!wget "https://lh3.googleusercontent.com/6o3C7AYzWbSWTKvlXIi4yBieFE-2fp9k2bPynvuDMGs5vYkqDC9OONR3oEjXJbp5UXMcRxqHfKMCpKOJ7uLhg83-COBRP8L_P-EJs-qi4G4VGXz7lJor0qFluu5lGZC_ItBj1yocyq_1jiZ8M8nKBeI48HeDJJxRuz6GAyCx5yxh9scHmmoCzte8t1LsHD5X1xb8c3bk1FLtp6eXMKosBXwK52MaM-SRVubc6RxYvZpEbhaEsEY8PIGgP3C7Viknakv_o5PvzU9FxHR8ywgmFSbbDyukouZI32jxlVFrEwdbzqrEUPz_IARigAbfXPywRy02uKX8c0cW91DQoEwJ9-HDzYp49hot7IdbucjM_vxGfMr_HkUDg0d1uKVqIF1Ikn7jMaPhuH9igbjT6-WdJjU3TgbjXdYqi9EwCYV5oGrqhlbPK6I1PDY2pJ43IBkzq4ZWI3Teye2dBAovNkcOfVJxPD1orCk5QgI7etwwcgu6Yaa9sCwcg3Fl2-Hd5jlSJCCm6APE608Q9xaGSFNSr51u758MFyraWuemyFIUx9r28pIX2McAe1gqAmZnE_Br57hH1bBqExpDHQOD2ensCz8FskTaZU0QCrl_cUEnZo1UjQeBhVjgJUY83uxMn0TYCAlRnYofERjjP9DA3lxyJOFgIxi3ItSGwsCdJoL_GAY0aM8KoxCtY3PkEnanm4Vs13L8fJwLJtgsF-GIii_t9kA6lv4plxehMuXdyi69c3g_2ss4FulEm_ec6lg10A=w663-h448-no?authuser=0&quot" -O "planetas.jpg"

#!wget "https://lh3.googleusercontent.com/Qs3QdBcaoFliztZrbU_KPi43Mai-81rHwkMuTf8iBqixE7oj4PBZISQG1XQtvRqN8h9X57hKpTNtMsXeLtQIS-1xDVjohvY0zFU-nyFf71KUSbcBh8u-uAiEJlzDmyY2u47QYM6htBdVCLXZYeVf3H3Y1T3q8rUmJxmHnFOSK4X3fWdGTMxVFZhxuWcZfbQDNSNSI0jZBtTbGGFg-rwUo52NDfQGLk70C2PDpvhyeVI9eP123clwnPwhpbMgueEOJ9sLX-S7zsvAjVoZGeaRrrkW0jXheLlirQbK94pSzvHZ1PN6yzhuqMc52GXvigZznO8T8UYykaJadDj48F05Lw6TI_wTxsYhdegzjABif11-g31SbpTuuFfkwWbWzQqjC6F3uaGmgiwYLEUb1Xa-2KstguRicMKGk5ElQ9EhuJXQ2ykHQ5jJzf6iccGmkK9modOoWS_a1jd2wuaSRwQO1ofaU3aNqkLacBL5vdvQp-o2nt5Z9QyvyMNN-N5pDSJcmqwTpERp_WnaQcBhwmkEZcFzFL7dM9ASDMYF24XOb5QVFETUkvnXzJSjWSbe18j6Ym1OG1ry6I7_mbsTrOYE9C5PZ0enwtA4zwnpCIovdkvAzWO6Yx-zJbwFSQaDUOzDPmRnOOnmZWx9CBXaUQTW2fBA8P1ii-yOBGPxuDWvWu0n5aV1EmpeNOaJ_la9mKcH4sm10A7BGLPSDb5KpqkD60A0fki4N_x75mWNbZvuUhCSAjNQIJX7Ibwe9wWvVA=w600-h257-no?authuser=0&quot" -O "olhos.jpg"

#!wget https://lh3.googleusercontent.com/pw/AM-JKLXYHn3MvPYFENHp8WNOCTdSpyT17nPJ5cx8Gpc3VNfgiBcwI4oeG99xTkVwLgc3bmJUZ5qVD7UZjtnlxedwk8ldslbJSyqZYcART71jdFqxHQ2UMgM8HtCHbC3fwMMaL4fviqqQDYlzxkA4TpQar7Nd=w252-h312-no?authuser=0 -O moedas.jpg

!wget https://lh3.googleusercontent.com/pw/AM-JKLVwzO4hmLK6LN_NAj-PAvOhXJh3DNOIFeMsbKt9h9kDeCjh9qI-KT1QalBY3GwdLJBrNDy5QpRe-aInncCuYSdME4lOLkSe_aXCvZdcIMwCDxbCOhWPdbbfCTCnZ03pk4_7XGEsg4zimKgujiPX-m0J=s600-no?authuser=0 -O cao.jpg

"""### **Fundamentos**"""

import cv2 as cv
import matplotlib.pyplot as plt

#carregar a imagem
img1 = cv.imread("peppers.jpg")

#converter BRG para RGB
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

#converter RGB para tons de cinza
img2 = cv.cvtColor(img1, cv.COLOR_RGB2GRAY)

#visualizar a imagem
plt.figure(figsize=(10,10))
plt.subplot(121), plt.imshow(img1),plt.axis('off')
plt.subplot(122), plt.imshow(img2, cmap='gray'),plt.axis('off')
plt.show()

"""### **Aula-22/02/2022**"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread("sail.tif")
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)
#img1 = cv.cvtColor(img1, cv.COLOR_BGR2GRAY)

#
#Propriedades da imagem
#
print(img1.shape)  #(largura,altura,número de canais)
print("Largura = %d" %img1.shape[0])
print("Altura  = %d" %img1.shape[1])
print("Canais  = %d" %img1.shape[2])

#Total de pixels da imagem
print("Total de pixels = %d" %img1.size)

#Acessar individualmente um pixel na imagem
r = img1.item(0,0,0)   # coordenada (0,0) do canal (0 = R)
g = img1.item(0,0,1)   # coordenada (0,0) do canal (1 = G)
b = img1.item(0,0,2)   # coordenada (0,0) do canal (1 = B)

print("RGB = (%d,%d,%d)" %(r,g,b))

"""### **Exercicios-22/02/2022**

**Exemplo**
"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread("sail.tif")
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)
img2 = cv.imread("sail.tif")
img2 = cv.cvtColor(img2,cv.COLOR_BGR2RGB)
img3 = cv.imread("sail.tif")
img3 = cv.cvtColor(img3,cv.COLOR_BGR2RGB)

for x in range(512):
  for y in range(768):
    img1.itemset((x,y,0), 255)
    img2.itemset((x,y,1), 255)
    img3.itemset((x,y,2), 255)

#

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img2), plt.axis('off')
plt.subplot(133), plt.imshow(img3), plt.axis('off')
plt.show()

"""**Ex02**"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread("sail.tif")
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2=img1.copy()
R, G, B = img2[:,:,0], img2[:,:,1], img2[:,:,2]
img2 = 0.2989 * R + 0.5870 * G + 0.1140 * B



plt.figure(figsize=(10,10))
plt.subplot(121), plt.imshow(img1),plt.axis('off')
plt.subplot(122),plt.imshow(img2, cmap='gray'),plt.axis('off')

plt.show()

"""#Separação de canais"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread("tulips.tif")
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

#separaçã de canais RGB
r,g,b=cv.split(img1)

#canal R (vermelho)
img_r=img1.copy()
img_r[:,:,0] = r
img_r[:,:,1] = 0
img_r[:,:,2] = 0

#canal G (verde)
img_g=img1.copy()
img_g[:,:,0] = 0
img_g[:,:,1] = g
img_g[:,:,2] = 0

#canal B (azul)
img_b=img1.copy()
img_b[:,:,0] = 0
img_b[:,:,1] = 0
img_b[:,:,2] = b


#visualizar a imagem
plt.figure(figsize=(10,5))
plt.subplot(221), plt.imshow(img1), plt.axis('off')
plt.subplot(222), plt.imshow(img_r), plt.axis('off'), plt.title('canal R'),
plt.subplot(223), plt.imshow(img_g), plt.axis('off'), plt.title('canal G'),
plt.subplot(224), plt.imshow(img_b), plt.axis('off'), plt.title('canal B'),

plt.show()

"""#Conversões: RGB>Gray e RGB>Bin"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar a imagem
img1 = cv.imread("peppers.jpg")

#converter BGR para RGB
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = np.zeros((img1.shape[0],img1.shape[1]), np.float32)
img3 = np.zeros((img1.shape[0],img1.shape[1]), np.float32)

for lin in range(img1.shape[0]):
  for col in range(img1.shape[1]):
    r = img1.item(lin,col,0)
    g = img1.item(lin,col,1)
    b = img1.item(lin,col,2)

    #converter RGB > GRAY
    #gray = (r+g+b)/3
    gray = r*0.299+g*0.587+b*0.114    # NTSC formula
    img2.itemset( (lin,col), gray)

    #converter RGB > BIN
    if (gray > 127):
      img3.itemset( (lin,col), 255)
    else:
      img3.itemset( (lin,col), 0)


#visualizar a imagem
plt.figure(figsize=(10,6))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img2,cmap='gray'), plt.axis('off')
plt.subplot(133), plt.imshow(img3,cmap='binary'), plt.axis('off')

plt.show()

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img = cv.imread('peppers.jpg')
img = cv.cvtColor(img, cv.COLOR_BGR2RGB)

img1 = np.zeros((img.shape[0], img.shape[1]), np.float32)

altura = img1.shape[0]
largura = img1.shape[1]


for lin in range(altura):
  for col in range(largura):
    #r = img.item(lin,col,0)
    #g = img.item(lin,col,1)
    #b = img.item(lin,col,2)
    r = img[lin][col][0]
    g = img[lin][col][1]
    b = img[lin][col][2]

    gray = (r+g+b)/3

    img1.itemset((lin,col), gray)


#Visualizar as imagem
plt.figure(figsize=(10,10))
plt.subplot(121),plt.imshow(img),plt.axis('off')
plt.subplot(122),plt.imshow(img1, cmap='gray'),plt.axis('off')
plt.show()

"""# Operações pontuais"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread('tulips.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = cv.imread('sail.tif')
img2 = cv.cvtColor(img2, cv.COLOR_BGR2RGB)

#print(img1.shape)
#print(img2.shape)

img3 = cv.add(img1, 60)#adição
img4 = cv.bitwise_not(img1)#negação
img5 = cv.addWeighted(img1,0.60,img2,0.80,0)#add ponderada
img6 = cv.add(img1,img2)#adição
img7 = cv.subtract(img1,img2)#subtração
img8 = cv.bitwise_and(img1,img2)#and
img9 = cv.bitwise_or(img1,img2)#or
img10 = cv.bitwise_xor(img1,img2)#xor



#Operações Pontuais

plt.figure(figsize=(20,20))
plt.subplot(441), plt.imshow(img1), plt.axis('off')
plt.subplot(442), plt.imshow(img2), plt.axis('off')
plt.subplot(443), plt.imshow(img3), plt.axis('off'), plt.title('adição')
plt.subplot(444), plt.imshow(img4), plt.axis('off'), plt.title('negação')
plt.subplot(445), plt.imshow(img5), plt.axis('off'), plt.title('add ponderada')
plt.subplot(446), plt.imshow(img6), plt.axis('off'), plt.title('adição')
plt.subplot(447), plt.imshow(img7), plt.axis('off'), plt.title('subtração')
plt.subplot(448), plt.imshow(img8), plt.axis('off'), plt.title('and')
plt.subplot(449), plt.imshow(img9), plt.axis('off'), plt.title('or')
plt.subplot(4,4,10), plt.imshow(img10), plt.axis('off'), plt.title('xor')
plt.show()

"""# Histogema"""

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread('tulips.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2GRAY)

#Histograma
h1 = cv.calcHist([img1],[0],None,[256],[0,255])

#Histograma Equalizado
img2 = cv.equalizeHist(img1)
h2 = cv.calcHist([img2],[0],None,[256],[0,255])

plt.figure(figsize=(10,6))
plt.subplot(221), plt.imshow(img1, cmap='gray'), plt.axis('off'),
plt.subplot(222), plt.plot(h1,'-',color='blue'), plt.xlim(0,255), plt.ylim(0,max(h1)+100), plt.title('histograma'),
plt.subplot(223), plt.imshow(img2, cmap='gray'), plt.axis('off'),
plt.subplot(224), plt.plot(h2,'.',color='blue'), plt.xlim(0,255), plt.ylim(0,max(h1)+100), plt.title('histograma equalizado'),

plt.show()

import cv2 as cv
import matplotlib.pyplot as plt

img1 = cv.imread('tulips.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

#Histograma Colorido
hr = cv.calcHist([img1],[0],None,[256],[0,255])
hg = cv.calcHist([img1],[1],None,[256],[0,255])
hb = cv.calcHist([img1],[2],None,[256],[0,255])

plt.figure(figsize=(18,4))
plt.subplot(121), plt.imshow(img1, cmap='gray'), plt.axis('off'),
plt.subplot(122), plt.plot(hr,'-',color='red'),plt.plot(hg,'-',color='green'), plt.plot(hb,'-',color='blue'),plt.xlim(0,255), plt.ylim(0,max(hr)+100), plt.title('histograma colorido'),
plt.show()

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('peppers.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

# FILTRO PASSA-BAIXA (suavização) -------
mask = np.ones( (3,3), np.float32) * (1/9)
img2 = cv.filter2D(img1,-1, mask)

mask = np.array( [[1,2,1],[2,4,2],[1,2,1]] )*(1/16)
img3 = cv.filter2D(img1,-1, mask)

img4 = cv.blur(img1, (15,15) )  #(9,9)=tamanho da mask
img5 = cv.medianBlur(img1, 21)
img6 = cv.GaussianBlur(img1, (5,5), 0)

# FILTRO PASSA-ALTA (realce) -------
mask = np.array( [[0,-1,0],[-1,5,-1],[0,-1,0]] )
img7 = cv.filter2D(img1,-1,mask)

mask = np.array( [[-1,-1,-1],[-1,9,-1],[-1,-1,-1]] )
img8 = cv.filter2D(img1,-1,mask)

mask = np.array( [[1,-2,1],[-2,5,-2],[1,-2,1]] )
img9 = cv.filter2D(img1,-1,mask)

plt.figure(figsize=(12,12))
plt.subplot(331), plt.imshow(img1),  plt.axis('off'), plt.title('original')
plt.subplot(332), plt.imshow(img2),  plt.axis('off'), plt.title('passa-baixa')
plt.subplot(333), plt.imshow(img3),  plt.axis('off'), plt.title('passa-baixa')
plt.subplot(334), plt.imshow(img4),  plt.axis('off'), plt.title('blur')
plt.subplot(335), plt.imshow(img5),  plt.axis('off'), plt.title('median blur')
plt.subplot(336), plt.imshow(img6),  plt.axis('off'), plt.title('gaussian blur')
plt.subplot(337), plt.imshow(img7),  plt.axis('off'), plt.title('passa-alta')
plt.subplot(338), plt.imshow(img9),  plt.axis('off'), plt.title('passa-alta')
plt.subplot(339), plt.imshow(img9),  plt.axis('off'), plt.title('passa-alta')
plt.show()

"""#Detectores de Borda"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('lena3.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2GRAY)

#Sobel
dx = cv.Sobel(img1, cv.CV_32F,1,0,ksize=3)
dy = cv.Sobel(img1, cv.CV_32F,0,1,ksize=3)

dx = cv.convertScaleAbs(dx)
dy = cv.convertScaleAbs(dy)
img2 = cv.addWeighted(dx,0.5,dy,0.5,0)

#Laplaciano
img3 = cv.Laplacian(img1,cv.CV_32F)
img3 = cv.convertScaleAbs(img3)

#Canny
img4 = cv.Canny(img1,100,120)

#Prewitt
mask = np.array([[-1,0,+1],[-1,0,+1],[-1,0,+1]])
img5 = cv.filter2D(img1,-1,mask)
mask = np.array([[-1,-1,-1],[0,0,0],[+1,+1,+1]])
img6 = cv.filter2D(img1,-1,mask)
img7 = cv.addWeighted(img5,0.5,img6,0.5,0)

plt.figure(figsize=(12,6))
plt.subplot(241), plt.imshow(img1,cmap='gray'),  plt.axis('off'), plt.title('original')
plt.subplot(242), plt.imshow(dx,cmap='binary'),  plt.axis('off'), plt.title('sobel - dx')
plt.subplot(243), plt.imshow(dy,cmap='binary'),  plt.axis('off'), plt.title('sobel - dy')
plt.subplot(244), plt.imshow(img2,cmap='binary'),  plt.axis('off'), plt.title('sobel')
plt.subplot(245), plt.imshow(img3,cmap='binary'),  plt.axis('off'), plt.title('laplaciano')
plt.subplot(246), plt.imshow(img4,cmap='binary'),  plt.axis('off'), plt.title('canny')
plt.subplot(247), plt.imshow(img7,cmap='binary'),  plt.axis('off'), plt.title('prewitt')
plt.show()

"""# Segmentação por Cor"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#geração de uma imagem artificial de 500x500 com 3 canais na cor branca
img1 = np.ones((500,500,3),np.uint8)*255
img1 = cv.circle(img1, (50,50), 30, (255,0,0), -1)
img1 = cv.circle(img1, (350,60), 40, (255,0,0), -1)
img1 = cv.circle(img1, (50,460), 50, (255,0,0), -1)
img1 = cv.circle(img1, (250,260), 40, (255,0,0), -1)
img1 = cv.circle(img1, (260,460), 30, (0,0,255), -1)
img1 = cv.circle(img1, (440,160), 50, (0,0,255), -1)
img1 = cv.circle(img1, (60,160), 50, (0,0,255), -1)
img1 = cv.circle(img1, (260,120), 50, (255,255,0), -1)
img1 = cv.circle(img1, (400,320), 50, (255,255,0), -1)
img1 = cv.circle(img1, (80,320), 50, (255,255,0), -1)
img1 = cv.circle(img1, (460,460), 30, (3,22,252), -1)

#CONVERTER RGB para HSV
img2 = cv.cvtColor(img1,cv.COLOR_RGB2HSV)

#SEGMENTAR os pixels no intervalo HSV AZUL
ini = np.array([116,0,0])
fim = np.array([180,255,255])
img3 = cv.inRange(img2,ini,fim)

#SEGMENTAR os pixels no intervalo HSV VERMELHO
ini = np.array([0,120,80])
fim = np.array([20,255,255])
img4 = cv.inRange(img2,ini,fim)

#SEGMENTAR os pixels no intervalo HSV AMARELO
ini = np.array([20,120,80])
fim = np.array([60,255,255])
img5 = cv.inRange(img2,ini,fim)

#CONVERTER um pixel em RGB para HSV
pixel = np.uint8([[[3,22,252]]])
print(cv.cvtColor(pixel,cv.COLOR_RGB2HSV))


plt.figure(figsize=(12,12))
plt.subplot(221), plt.imshow(img1), plt.axis('off')
plt.subplot(222), plt.imshow(img3,cmap='binary'), plt.axis('off'), plt.title('azul'),
plt.subplot(223), plt.imshow(img4,cmap='binary'), plt.axis('off'), plt.title('vermelho'),
plt.subplot(224), plt.imshow(img5,cmap='binary'), plt.axis('off'), plt.title('amarelo'),
plt.show()

"""Ex 04

"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('tulips.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)
img2 = cv.cvtColor(img1,cv.COLOR_RGB2HSV)

ini = np.array([116,0,0])
fim = np.array([180,255,255])
img3 = cv.inRange(img2,ini,fim)

ini = np.array([0,120,80])
fim = np.array([20,255,255])
img4 = cv.inRange(img2,ini,fim)

ini = np.array([20,120,80])
fim = np.array([60,255,255])
img5 = cv.inRange(img2,ini,fim)

plt.figure(figsize=(12,12))
plt.subplot(221), plt.imshow(img1), plt.axis('off')
plt.subplot(222), plt.imshow(img3,cmap='binary'), plt.axis('off'), plt.title('azul'),
plt.subplot(223), plt.imshow(img4,cmap='binary'), plt.axis('off'), plt.title('vermelho'),
plt.subplot(224), plt.imshow(img5,cmap='binary'), plt.axis('off'), plt.title('amarelo'),
plt.show()

"""Ex 05"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np


img1 = cv.imread('lena3.tif')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

"""# Exercícios Parcial

Ex01
"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'
imgName2 = 'peppers.jpg'
imgName3 = 'bird-7071662_960_720.jpg'
img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.imread(imgName2)
img2 = cv.cvtColor(img2,cv.COLOR_BGR2RGB)
img3 = cv.imread(imgName3)
img3 = cv.cvtColor(img3,cv.COLOR_BGR2RGB)


img4 = np.zeros((img2.shape[0],img2.shape[1]), np.float32)
img5 = np.zeros((img3.shape[0],img3.shape[1]), np.float32)


for x in range(img2.shape[0]):
  for y in range(img2.shape[1]):
    r = img2.item(x,y,0)
    g = img2.item(x,y,1)
    b = img2.item(x,y,2)
    result = ((r+g+b)/3)
    img4.itemset((x,y),result)

for x in range(img3.shape[0]):
  for y in range(img3.shape[1]):
    r = img3.item(x,y,0)
    g = img3.item(x,y,1)
    b = img3.item(x,y,2)
    result = ((r+g+b)/3)
    if(result> 127):
      img5.itemset((x,y),255)
    else:
      img5.itemset((x,y),0)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off') , plt.title("Total de pixels img1 = %d" %img1.size)
plt.subplot(132), plt.imshow(img4, cmap="gray"), plt.axis('off') , plt.title("Numero de linhas img2 = %d" %img2.shape[1])
plt.subplot(133), plt.imshow(img5, cmap="binary" ), plt.axis('off'),  plt.title("Numero de linhas img3 = %d" %img3.shape[0])
plt.show()

"""Ex02"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'
imgName2 = 'peppers.jpg'
imgName3 = 'mar.jpg'
imgName4 = '512.jpg'
img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.imread(imgName2)
img2 = cv.cvtColor(img2,cv.COLOR_BGR2RGB)
img3 = cv.imread(imgName3)
img3 = cv.cvtColor(img3,cv.COLOR_BGR2RGB)
img4 = cv.imread(imgName4)
img4 = cv.cvtColor(img4,cv.COLOR_BGR2RGB)


print("Largura = %d" %img4.shape[0])
print("Altura  = %d" %img4.shape[1])



img5 = ((img1+img2)+(img3*0.5)+(img4-img1)) %255
img6 = cv.bitwise_not(img1)



hr1 = cv.calcHist([img1],[0],None,[256],[0,255])
hg1 = cv.calcHist([img1],[1],None,[256],[0,255])
hb1 = cv.calcHist([img1],[2],None,[256],[0,255])


hr6 = cv.calcHist([img6],[0],None,[256],[0,255])
hg6 = cv.calcHist([img6],[1],None,[256],[0,255])
hb6 = cv.calcHist([img6],[2],None,[256],[0,255])

plt.figure(figsize=(20,20))
plt.subplot(331), plt.imshow(img1), plt.axis('off')
plt.subplot(332), plt.imshow(img2), plt.axis('off')
plt.subplot(333), plt.imshow(img3), plt.axis('off')
plt.subplot(334), plt.imshow(img4), plt.axis('off')
plt.subplot(335), plt.imshow(img5), plt.axis('off')
plt.subplot(336), plt.imshow(img6), plt.axis('off')
plt.subplot(337), plt.plot(hr1,'-',color='red'),plt.plot(hg1,'-',color='green'), plt.plot(hb1,'-',color='blue'),plt.xlim(0,255), plt.ylim(0,max(hr1)+100), plt.title('histograma img1'),
plt.subplot(338), plt.plot(hr6,'-',color='red'),plt.plot(hg6,'-',color='green'), plt.plot(hb6,'-',color='blue'),plt.xlim(0,255), plt.ylim(0,max(hr6)+100), plt.title('histograma img6'),
plt.show()

"""Ex03"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'
imgName2 = 'peppers.jpg'

img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.imread(imgName2)
img2 = cv.cvtColor(img2,cv.COLOR_BGR2RGB)

img3 = cv.addWeighted(img2,0.60,img1,0.90,0)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img2), plt.axis('off')
plt.subplot(133), plt.imshow(img3), plt.axis('off')
plt.show()

"""Ex04"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'

img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)

img2 = cv.cvtColor(img1,cv.COLOR_RGB2HSV)

# Segmentação do vermelho

inicio = np.array([5,95,80])
fim = np.array([60,130,250])
img3 = cv.inRange(img2,inicio,fim)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img3,cmap='binary'), plt.axis('off')
plt.show()

"""Ex05"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'

img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)


resultX = (int) (img1.shape[0]+(img1.shape[0]0.5))
resultY = (int) (img1.shape[1]+(img1.shape[0]0.5))


img2 = cv.resize(img1,(resultX,resultY))





plt.figure(figsize=(20,20))
plt.subplot(121), plt.imshow(img1), plt.axis('off') ,plt.title('X = %d ' %img1.shape[0] +'Y = %d' %img1.shape[1])
plt.subplot(122), plt.imshow(img2), plt.axis('off'), plt.title('X = %d ' %img2.shape[0] +'Y = %d' %img2.shape[1])
plt.show()

"""Ex06"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

#carregar imagem
imgName1 = 'lena3.tif'

img1 = cv.imread(imgName1)
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)

img2 = img1.copy()

R, G, B = img2[:,:,0], img2[:,:,1], img2[:,:,2]

img2[:,:,0] = 0.2989 * R + 0.5870 * G + 0.1140 * B
img2[:,:,1] = 0.2989 * R + 0.5870 * G + 0.1140 * B
img2[:,:,2] = 0.2989 * R + 0.5870 * G + 0.1140 * B

img3 = img2.copy()

img3[:,:,0] = (0.2989 * R + 0.5870 * G + 0.1140 * B) + 50
img3[:,:,1] = (0.2989 * R + 0.5870 * G + 0.1140 * B) + 50
img3[:,:,2] = (0.2989 * R + 0.5870 * G + 0.1140 * B) + 50

print(img2.shape)

h1 = cv.calcHist([img2],[0],None,[256],[0,255])
h2 = cv.calcHist([img3],[0],None,[256],[0,255])



plt.figure(figsize=(20,20))
plt.subplot(221), plt.imshow(img2, cmap = 'gray'), plt.axis('off')
plt.subplot(222),plt.plot(h1,'-',color='blue'),plt.xlim(0,255), plt.ylim(0,max(h1)+100), plt.title('histograma img2'),
plt.subplot(223), plt.imshow(img3, cmap = 'gray'), plt.axis('off')
plt.subplot(224),plt.plot(h2,'-',color='blue'),plt.xlim(0,255), plt.ylim(0,max(h2)+100), plt.title('histograma img3'),
plt.show()

"""# Contornos"""

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('estrelas.png')
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.cvtColor(img1, cv.COLOR_RGB2GRAY)
th, img2 = cv.threshold(img2,20,220,cv.THRESH_BINARY)

#
# Extração dos contornos
#
contornos, ordem = cv.findContours(img2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)
print("Total de contornos: {0}".format(len(contornos)))

#
# Ordenar os contornos pela Área (Menor para o Maior)
#
contornos = sorted(contornos, key = cv.contourArea)

print("Tamanho do MENOR contorno: {0}".format(len(contornos[0])))
print("Tamanho do MAIOR contorno: {0}".format(len(contornos[5])))

#
# Visualizar os contornos
#
img3 = img1.copy()
cv.drawContours(img3, contornos, 0, (255,0,0), 2)
cv.drawContours(img3, contornos, 5, (255,0,0), 2)

plt.figure(figsize=(12,6))
plt.subplot(121), plt.imshow(img2, cmap='binary'),  plt.axis('off')
plt.subplot(122), plt.imshow(img3),  plt.axis('off')
plt.show()

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('estrelas.png')
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.cvtColor(img1, cv.COLOR_RGB2GRAY)
th, img2 = cv.threshold(img2,20,220,cv.THRESH_BINARY)


# - Extrair o contorno da image
contornos, ordem = cv.findContours(img2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)



img3 = img1.copy()
for c in contornos:
  # - Determinar o BOUNDING BOX
  x,y,larg,alt = cv.boundingRect(c)
  cv.rectangle(img3, (x,y), (x+larg,y+alt),(255,0,0),2 )

  # - Determinar o BOUNDING BOX considerando a ROTAÇÃO
  area = cv.minAreaRect(c)
  box = cv.boxPoints(area)  # calcular as coordenadas do obj
  box = np.int0(box)        # transformar as coordenadas em inteiros
  cv.drawContours(img3, [box], 0, (255,255,0), 2)

  # - Determinar o CIRCULO MÍNIMO
  (x,y), raio = cv.minEnclosingCircle(c)
  centro = (int(x),int(y))
  raio = int(raio)
  cv.circle(img3, centro, raio, (0,255,255),2)


#cv.drawContours(img3, contornos, -1, (255,255,255), 2)

plt.figure(figsize=(12,6))
plt.subplot(131), plt.imshow(img2, cmap='binary'),  plt.axis('off')
plt.subplot(132), plt.imshow(img3),  plt.axis('off')
plt.show()

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np

img1 = cv.imread('apple.png')
img1 = cv.cvtColor(img1,cv.COLOR_BGR2RGB)
img2 = cv.cvtColor(img1, cv.COLOR_RGB2GRAY)
th, img2 = cv.threshold(img2,240,255,cv.THRESH_BINARY_INV)

contornos, ordem = cv.findContours(img2, cv.RETR_TREE, cv.CHAIN_APPROX_SIMPLE)

img3 = cv.bitwise_not( img2.copy())
img3 = cv.cvtColor(img3, cv.COLOR_GRAY2RGB)
cv.drawContours(img3, contornos, -1, (0,0,255), 10)

for c in contornos:
  # - Determinar o CONTORNO APROXIMADO
  epsilon = 0.01 * cv.arcLength(c, True)     # Acurácia da Aproximação
  aprox = cv.approxPolyDP(c, epsilon, True)
  cv.drawContours(img3, [aprox], -1, (255,255,0), 10)

  # - Determinar o CONVEX HULL
  hull = cv.convexHull(c)
  cv.drawContours(img3, [hull], -1, (255,0,0), 10)


plt.figure(figsize=(12,6))
plt.subplot(121), plt.imshow(img2, cmap='binary'),  plt.axis('off')
plt.subplot(122), plt.imshow(img3),  plt.axis('off')
plt.show()

"""#Segmentação com GrabCut"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('estatua.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

#
# Definir o retângulod de segmentação
#
img2 = img1.copy()
p1 = (60,25)
p2 = (420,400)
img2 = cv.rectangle(img2, p1,p2, (255,0,0),1)

#
# Parâmetros do algoritmo
#
mascara = np.zeros(img1.shape[:2], np.uint8)
bgModel = np.zeros((1,65),np.float64)
fgModel = np.zeros((1,65),np.float64)
retangulo = p1+p2

#
# GRABCUT
#
cv.grabCut(img1,mascara,retangulo,bgModel,fgModel,3,cv.GC_INIT_WITH_RECT)


#
# Separar o BACKGROUND do FOREGROUND
# Após a execução do algoritmo, a variável máscara contém valores
# entre 0 e 3.
# Valores iguais a 0 ou 2 ==> Background
# Valores iguais a 1 ou 3 ==> Foreground
filtro = np.where( (mascara==1)|(mascara==3),0, 1).astype('uint8')
img3 = img1.copy()
img3 = img3 * filtro[:,:,np.newaxis]


plt.figure(figsize=(10,10))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img2), plt.axis('off')
plt.subplot(133), plt.imshow(img3), plt.axis('off')
plt.show()

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('estatua.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

#
# Definir o retângulod de segmentação
#
img2 = img1.copy()
p1 = (60,20)
p2 = (420,400)
img2 = cv.rectangle(img2, p1,p2, (255,0,0),1)

#
# Parâmetros do algoritmo
#
mascara = np.zeros(img1.shape[:2], np.uint8)
bgModel = np.zeros((1,65),np.float64)
fgModel = np.zeros((1,65),np.float64)
retangulo = p1+p2

#
# GRABCUT
#
cv.grabCut(img1,mascara,retangulo,bgModel,fgModel,2,cv.GC_INIT_WITH_RECT)


#
# Separar o BACKGROUND do FOREGROUND
# Após a execução do algoritmo, a variável máscara contém valores
# entre 0 e 3.
# Valores iguais a 0 ou 2 ==> Background
# Valores iguais a 1 ou 3 ==> Foreground
filtro = np.where( (mascara==0)|(mascara==2),0, 1).astype('uint8')
img3 = img1.copy()
img3 = img3 * filtro[:,:,np.newaxis]


plt.figure(figsize=(10,10))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img2), plt.axis('off')
plt.subplot(133), plt.imshow(img3), plt.axis('off')
plt.show()

"""#Transformada de Hough"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('rodovia.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = img1.copy()
img2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)
img2 = cv.Canny(img2,500,200)

#
# TRANSFORMADA DE HOUGH
#
p1 = 100    # linhas menores que 100 pixels serão descartadas
p2 = 50     # gap com no máximo 50 pixels
p3 = 45     # número mínimo de intersecções para detectar a linha

linhas = cv.HoughLinesP(img2,1,np.pi/180,threshold=p3,minLineLength=p1,maxLineGap=p2)

img3 = img1.copy()
if linhas is not None:
  print("Qtde de linhas encontradas: %i" %len(linhas))

  #exibir as linhas
  for lin in linhas:
    x1,y1,x2,y2 = lin[0]
    cv.line(img3,(x1,y1),(x2,y2),(255,0,0),1)
else:
  print("Nenhuma linha encontrada")

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img3), plt.axis('off')
plt.show()

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('planetas.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = img1.copy()
img2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)
img2 = cv.medianBlur(img2,5)

#
# TRANSFORMADA DE HOUGH
#
circulos = cv.HoughCircles(img2, cv.HOUGH_GRADIENT,1,120,param1=200,param2=30,minRadius=0,maxRadius=0)
circulos = np.uint16(np.around(circulos))

img3 = img1.copy()
if circulos is not None:
  print("Qtde de círculos encontrados: %i" %len(circulos[0,:]))

  for c in circulos[0,:]:
    cv.circle(img3,(c[0],c[1]),c[2],(255,0,0),3)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img3), plt.axis('off')
plt.show()

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('olhos.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = img1.copy()
img2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)
img2 = cv.medianBlur(img2,5)

#
# TRANSFORMADA DE HOUGH
#
circulos = cv.HoughCircles(img2, cv.HOUGH_GRADIENT,1,120,param1=200,param2=25,minRadius=0,maxRadius=0)
circulos = np.uint16(np.around(circulos))

img3 = img1.copy()
if circulos is not None:
  print("Qtde de círculos encontrados: %i" %len(circulos[0,:]))

  for c in circulos[0,:]:
    cv.circle(img3,(c[0],c[1]),c[2],(255,0,0),3)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img3), plt.axis('off')
plt.show()

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('olhos.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

img2 = img1.copy()
img2 = cv.cvtColor(img2, cv.COLOR_BGR2GRAY)
img2 = cv.medianBlur(img2,5)

#
# TRANSFORMADA DE HOUGH
#
circulos = cv.HoughCircles(img2, cv.HOUGH_GRADIENT,1,120,param1=200,param2=15,minRadius=0,maxRadius=0)
circulos = np.uint16(np.around(circulos))

img3 = img1.copy()
if circulos is not None:
  print("Qtde de círculos encontrados: %i" %len(circulos[0,:]))

  for c in circulos[0,:]:
    cv.circle(img3,(c[0],c[1]),c[2],(255,0,0),3)

plt.figure(figsize=(20,20))
plt.subplot(131), plt.imshow(img1), plt.axis('off')
plt.subplot(132), plt.imshow(img3), plt.axis('off')
plt.show()

"""# Segmentação com Watershed"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('moedas.jpg')
img1 = cv.cvtColor(img1, cv.COLOR_BGR2RGB)

# Transformar a imagem em binário
img2 = cv.cvtColor(img1,cv.COLOR_BGR2GRAY)
th, img2 = cv.threshold(img2,0,255,cv.THRESH_BINARY_INV+cv.THRESH_OTSU)

# Morfologia Matemática --------------------------------------------------------

# operação de abertura para remover pequenos ruídos da imagem
kernel = np.ones((3,3),np.uint8)
img3 = cv.morphologyEx(img2,cv.MORPH_OPEN, kernel, iterations=2)

# preencher pequenos espaços na imagem
img4 = cv.dilate(img3,kernel,iterations=1)

# transformada da distância
img5 = cv.distanceTransform(img4,cv.DIST_L2,5)
th, img6 = cv.threshold(img5,0.70*img5.max(),255,0)

# Watershed --------------------------------------------------------------------
img6 = np.uint8(img6)      # converter matriz para inteiros
img7 = cv.subtract(img4,img6)

#rotular os componentes conectados da imagem
ret,rotulos = cv.connectedComponents(img6)
rotulos = rotulos + 1

#marcar a região do watershed com o valor 0
rotulos[img7==255] = 0
img8 = cv.watershed(img1,rotulos)
img1[rotulos == -1] = [255,0,0]


plt.figure(figsize=(15,8))
plt.subplot(241), plt.imshow(img1), plt.axis('off')
plt.subplot(242), plt.imshow(img2,cmap='binary'), plt.axis('off'), plt.title('binária')
plt.subplot(243), plt.imshow(img3,cmap='binary'), plt.axis('off'), plt.title('abertura')
plt.subplot(244), plt.imshow(img4,cmap='binary'), plt.axis('off'), plt.title('dilatação')
plt.subplot(245), plt.imshow(img5,cmap='gray'), plt.axis('off'), plt.title('dist.transform')
plt.subplot(246), plt.imshow(img7,cmap='binary'), plt.axis('off'), plt.title('subtração')
plt.subplot(247), plt.imshow(img8,cmap='jet'), plt.axis('off'), plt.title('subtração')
plt.show()

"""# Representação e Descrição"""

import cv2 as cv
import numpy as np
import matplotlib.pyplot as plt

img1 = cv.imread('cao.jpg')
img1 = cv.cvtColor(img1,cv.COLOR_BGR2GRAY)
th,img1 = cv.threshold(img1,127,255,cv.THRESH_BINARY_INV)

#
# TÉCNICA DE AFINAMENTO
#
img2 = np.zeros(img1.shape,np.uint8)
kernel = cv.getStructuringElement(cv.MORPH_CROSS,(3,3))

fim = False
img3 = img1.copy()
while (not fim):
  erosao = cv.erode(img3,kernel)
  dilatacao = cv.dilate(erosao,kernel)
  temp = cv.subtract(img3,dilatacao)
  img2 = cv.bitwise_or(img2,temp)
  img3 = erosao.copy()

  zeros = np.size(img3) - cv.countNonZero(img3)
  if (zeros == np.size(img3)):
    fim = True

_,img2 = cv.threshold(img2,10,255,cv.THRESH_BINARY_INV)
cv.add(img1,img2)

plt.figure(figsize=(15,10))
plt.subplot(121), plt.imshow(img1,cmap='binary'), plt.axis('off')
plt.subplot(122), plt.imshow(img2,cmap='binary'), plt.axis('off')
plt.show()

import cv2 as cv
import numpy as np
import math
import matplotlib.pyplot as plt

img1 = cv.imread('cao.jpg')
img1 = cv.cvtColor(img1,cv.COLOR_BGR2GRAY)
th,img1 = cv.threshold(img1,127,255,cv.THRESH_BINARY_INV)


#
# DESCRITORES DE BORDA
#

# Perímetro
contorno,ordem = cv.findContours(img1,cv.RETR_TREE,cv.CHAIN_APPROX_SIMPLE)
perimetro = cv.arcLength(contorno[0],True)
print('Perímetro: {0}'.format(int(perimetro)))

perimetro = cv.countNonZero(cv.Canny(img1,50,100))
print('Perímetro: {0}'.format(int(perimetro)))

# Diâmetro
diametro = np.sqrt(4*cv.contourArea(contorno[0])/np.pi)
print('Diâmetro: {0}'.format(int(diametro)))

#
# DESCRITORES DE REGIÃO
#

# Área
area = cv.countNonZero(img1)
print('Área: {0}'.format(int(area)))

# Compacidade
compacidade = np.square(perimetro)/area
print('Compacidade: {0}'.format(int(compacidade)))

# Projeções
lin,col = img1.shape
proj_vert = []
for i in range(0,col):
  proj_vert.append(cv.countNonZero(img1[:,i]))

proj_horiz = []
for i in range(0,lin):
  proj_horiz.append(cv.countNonZero(img1[i,:]))

plt.figure(figsize=(12,3))
plt.subplot(131), plt.imshow(img1,cmap='binary')
plt.subplot(132), plt.plot(range(0,col),proj_vert,'-'), plt.xlim([0,col]), plt.ylim([0,np.max(proj_vert)+100])
plt.subplot(133), plt.plot(range(0,lin),proj_horiz,'-'), plt.xlim([0,lin]), plt.ylim([0,np.max(proj_horiz)+100])
plt.show()


# Eixo Maior, Eixo Menor e Excentricidade
(x,y), (eixoMenor, eixoMaior), angulo = cv.fitEllipse(contorno[0])
print('Eixo Maior: {0:.2f}'.format(eixoMaior))
print('Eixo Menor: {0:.2f}'.format(eixoMenor))
print('Excentricidade: {0:.2f}'.format(eixoMaior/eixoMenor))

# Solidez
area_obj = cv.contourArea(contorno[0])
area_fecho_convexo = cv.contourArea(cv.convexHull(contorno[0]))
solidez = area_obj/area_fecho_convexo

print('Área objeto: {0:.2f}'.format(area_obj))
print('Área fecho convexo: {0:.2f}'.format(area_fecho_convexo))
print('Solidez: {0:.2f}'.format(solidez))

# Momentos de Hu
momentos = cv.moments(img1)
momentos_hu = cv.HuMoments(momentos)
print('Momentos Hu: {0}'.format(momentos_hu))

for i in range(0,7):
   momentos_hu[i] = -1* math.copysign(1.0, momentos_hu[i]) * math.log10(abs(momentos_hu[i]))
print('Momentos Hu: {0}'.format(momentos_hu))

"""# Reconhecimento de Padrões"""

from google.colab import drive
drive.mount('/content/drive')

import pandas as pd
import numpy as np
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score


# importar o conjunto de dados
#dados = pd.read_csv('iris_dataset.csv',sep=';')
#dados.describe()
dados = pd.read_csv("drive//MyDrive//frutasdb.csv//", sep=';')


# separar as características e a classe
X = dados.iloc[:,0:4]  # características
y = dados.iloc[:,4]    # class


# PRÉ-PROCESSAMENTO
# Normalização do conjunto de dados
normalizar = StandardScaler()
normalizar.fit(X)
X = normalizar.transform(X)

# PROCESSAMENTO
# Dividir o conjunto em treinamento (TRAIN) e teste (TEST)
XTrain, XTest, yTrain, yTest = train_test_split(X,y,test_size=0.30,random_state=35)

# CLASSIFICADOR
knn = KNeighborsClassifier(n_neighbors = 5)
knn.fit(XTrain, yTrain)
Y = knn.predict(XTest)

# RESULTADO
acc = accuracy_score(yTest,Y)
print('Acurácia: {0:.4f}\n\n'.format(acc))

#Matriz de confusão
print(pd.crosstab(yTest,Y,rownames=['True'],colnames=['Predição'],
                  margins=True))

import cv2 as cv
import matplotlib.pyplot as plt
import numpy as np
from os import walk
from os import listdir
import csv

drive = "drive//MyDrive//frutasdb//"

imgs = []
for (dirpath, dirnames, filenames) in walk(drive):
  imgs.extend(filenames)

imgs.sort()
print(imgs)
list_img = []
for i in range(len(imgs)):
    list_img.append([imgs[i], cv.imread(drive + imgs[i], 0)])
    kernel = np.ones((3,3),np.uint8)
    list_img[i][1] = cv.morphologyEx(list_img[i][1], cv.MORPH_OPEN, kernel, iterations = 2)
    mask = np.ones((6,6),np.float32)*1/9
    list_img[i][1] = cv.filter2D(list_img[i][1],-1,mask)
    list_img[i][1] = cv.resize(list_img[i][1], (30, 30), interpolation = cv.INTER_AREA)
    contorno, ordem = cv.findContours(list_img[i][1], cv.RETR_TREE, cv.CHAIN_APPROX_NONE)
    #diametro
    diametro = np.sqrt(4*cv.contourArea(contorno[0])/np.pi )
    list_img[i].append(diametro)
    perimetro = cv.arcLength(contorno[0], True)
    list_img[i].append(perimetro)
    # Área
    area = cv.countNonZero(list_img[i][1])
    list_img[i].append(area)
    # Compacidade
    compacidade = np.square(perimetro)/area
    list_img[i].append(compacidade)
     #excentricidade
    (x,y), (eixoMenor,eixoMaior),angulo = cv.fitEllipse(contorno[0])
    excentricidade = (eixoMaior/eixoMenor)
    list_img[i].append(excentricidade)
    #retangularidade
    retangularidade = area/(eixoMaior*eixoMenor)
    list_img[i].append(retangularidade)
    #label
    if( i<= 30):
        list_img[i].append('Maca')
    elif(i <= 60):
        list_img[i].append('abacaxi')
    elif(i<= 90):
        list_img[i].append('banana')
    elif(i<= 120):
        list_img[i].append('peseego')
    elif(i <= 150):
        list_img[i].append('pitanga')
    elif(i <= 180):
        list_img[i].append('laranja')
    elif(i <= 210):
        list_img[i].append('morango')
    elif(i <= 240):
        list_img[i].append('pera')
    elif(i <= 270):
        list_img[i].append('limao')
    elif(i <= 300):
        list_img[i].append('uva')





csv_list = []
for i in range(len(list_img)):
    csv_list.append([list_img[i][2], list_img[i][3],list_img[i][4],list_img[i][5], list_img[i][6], list_img[i][7], list_img[i][8]])

with open('img_data.csv', 'w') as myfile:                                     #gera um arquivo em formato csv para armazenar os dados gerados
    wr = csv.writer(myfile, dialect='excel')
    wr.writerow(['Diametro','Perimetro', 'Area', 'Compacidade', 'excentricidade',  'retangularidade','label'])
    i = 0
    while i < len(csv_list):
      wr.writerow(csv_list[i])
      i = i + 1

#plotando pra saber se está lendo corretamente as imagens
# print(len(imgs))
# plt.figure(figsize=(10,10))
# plt.subplot(121), plt.imshow(list_img[0][1],cmap='binary')
# plt.subplot(122), plt.imshow(list_img[-1][1],cmap='binary')
# plt.show()

import numpy as np
import pandas as pd
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from sklearn.metrics import accuracy_score
from sklearn import linear_model, datasets


# # carregar o arquivo com as características
df = pd.read_csv('img_data.csv', sep=',')
df.describe()

#print(df)

# # # separar as características e os rótulos
X = df.iloc[:,0:6]    # características
y = df.iloc[:,6]      # rótulos
# print(y)
# print(X)

# #
# # PRÉ-PROCESSAMENTO
# #
normalizar = StandardScaler()
normalizar.fit(X)
X = normalizar.transform(X)
#print(X)

# #
# # PROCESSAMENTO
# # Dividir o conjunto de dados em treinamento (TRAIN) e teste (TEST)
# #
XTrain, XTest, yTrain, yTest = train_test_split(X,y,test_size=0.40, random_state=35)

# # #
# # # CLASSIFICADOR
# # #
knn = KNeighborsClassifier(n_neighbors = 5)
knn.fit(XTrain, yTrain)
Y = knn.predict(XTest)

# # #
# # # RESULTADO
# # #
acc = accuracy_score(yTest, Y)
print('Acurácia: {0:.2f}\n\n'.format(acc))

# # # Matriz confusão
print(pd.crosstab(yTest,Y,rownames=['True'],colnames=['Predição'],margins=True))

#plotando pra saber se está lendo corretamente as imagens
# print(len(imgs))
# plt.figure(figsize=(10,10))
# plt.subplot(121), plt.imshow(list_img[0][1],cmap='binary')
# plt.subplot(122), plt.imshow(list_img[-1][1],cmap='binary')
# plt.show()